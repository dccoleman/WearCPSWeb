---
title: "WearCPS: Safety vs. Security Analysis"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
load("Data.Rdata")

library(ggplot2)
library(pwr)

```

## Introduction

Below is the initial analyis/breakdown of the test data collected through our website **WearCPS.me**.

## Average Ages

Average ages of participants:

```{r analysis, incude=TRUE}

summary(Ages$age)

ggplot(Ages, aes(x=age)) +  geom_dotplot(binwidth = .3) +
  scale_y_continuous(name = "", breaks = NULL) + ggtitle("Average Ages") +
  labs(x="Ages",y="Ages") 
```

## Avg. Score

Basic plot of Avg. Score:

```{r analysis2, incude=TRUE}

summary(SexVsScore)

ggplot(SexVsScore, aes(x=finalScore)) +  geom_density(kernel = "gaussian", fill='orange', alpha=0.25) + ggtitle("Avg. Score") + labs(x="Score", y ="Density") +
  scale_y_continuous(name = "", breaks = NULL)
```

## Avg. Response Time

Basic plot of Avg. Response Times:

```{r analysis3, incude=TRUE}

summary(NotificationResponseTimes)

x <- data.frame(Average=NotificationResponseTimes$avg,Security=NotificationResponseTimes$secAvg,Safety=NotificationResponseTimes$safAvg)
library(ggplot2);library(reshape2)
data<- melt(x)
ggplot(data,aes(x=value, fill=variable)) + geom_density(alpha=0.25) + ggtitle("Response Times") + labs(x="Time(ms)", y ="Density") +
  scale_y_continuous(name = "", breaks = NULL)
```

## Notification Correctness

Basic plot of Notification Correctness:

```{r analysis4, incude=TRUE}

summary(NotificationResponseCorrectness)

x <- data.frame(Average=NotificationResponseCorrectness$avgCorrect,Security=NotificationResponseCorrectness$secAvgCorrect,Safety=NotificationResponseCorrectness$safAvgCorrect)
library(ggplot2);library(reshape2)
data<- melt(x)
ggplot(data,aes(x=value, fill=variable)) + geom_density(alpha=0.25) + ggtitle("Notification Correctness") + labs(x="Percent Correct", y ="Density") +
  scale_y_continuous(name = "", breaks = NULL)

```

## Recall Correctness

Basic plot of Recall Correctness:

```{r analysis5, incude=TRUE}

summary(RecallCorrectPercentages)

x <- data.frame(Average=RecallCorrectPercentages$avgPercent,Security=RecallCorrectPercentages$secPercent,Safety=RecallCorrectPercentages$safPercent)
library(ggplot2);library(reshape2)
data<- melt(x)
ggplot(data,aes(x=value, fill=variable)) + geom_density(alpha=0.25) + ggtitle("Recall Correctness") + labs(x="Percent Correct", y ="Density") +
  scale_y_continuous(name = "", breaks = NULL)

```

```{r analysis6, include=TRUE}
library(dplyr)
library(boot)
library(ggplot2)



# Bootstrap 95% CI for mean
# function to obtain mean from the data (with indexing)
mean.fun <- function(D, d) {
  return( mean(D[d]) )
}

data <- filterResponseTimesPerRow

# CI plot
# Example of usage: ciplot("myDependentVariable","myIndependentVariable") 
ciplot <- function(xVar, yVar) {
  
  groups <- group_by_(data, xVar)
  
  # Note: So far it is the only way found to enable variable name as string parameter for the function
  groupedData <- eval(parse(text=sprintf("summarize(groups, 
                                         mean=mean(%s),
                                         UCI=boot.ci(boot(%s, statistic = mean.fun, R=1000, sim=\"ordinary\"))$bca[,5],
                                         LCI=boot.ci(boot(%s, statistic = mean.fun, R=1000, sim=\"ordinary\"))$bca[,4])",
                                         yVar, yVar, yVar)))
  
  # Note: Another way to compute bootstrap CIs (boot library is used here instead), is to compute it mannually.
  # By adding mutate(se=sd/sqrt(n),lower=resp+qnorm(0.025)*se,upper=resp+qnorm(0.975)*se)
  df <- data.frame(
    trt = factor(groupedData[[1]]),
    resp = groupedData[["mean"]],
    group = factor(groupedData[[1]]),
    upper = c(groupedData[["UCI"]]),
    lower = c(groupedData[["LCI"]])
  )
 
  # Plot CI
  p <- ggplot(df, aes(trt, resp))
  p <- p + theme(axis.title=element_text(size=20), axis.text=element_text(size=18))
  p <- p + geom_pointrange(aes(ymin = lower, ymax = upper)) 
  p <- p + expand_limits(y = 0) 
  p <- p + ylab(yVar) 
  p <- p + xlab("") 
  p <- p + geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.1) 
  #p <- p + coord_flip() #Can flip the coordinate here
  p
}

summary(filterResponseTimesPerRow)
ciplot("Type", "ResponseTime")

```

```{r}
library(bootES)

reportES <- function(attr) {
  b <- bootES(data, 
              data.col=attr, 
              group.col="Type", 
              contrast=c(Safety=1,Security=-1), 
              effect.type="cohens.d"
  )
  
  cat( "d=",     round( b$t0, 2), "~", 
       "[", round( b$bounds[1], 2), ",", 
       round( b$bounds[2], 2), "]", 
       sep="")
}

reportES("ResponseTime")

```

### Power Analysis
```{r}
# Example (breaking down the functions)
# Effect Size is the key. 
# While we have good estimates of variability from a given metric (like visited),
# the means of group 1 and 2 are something we should reason about.
# It's helpful to plug different means in (hypothetical means) to see how suggested "n" changes.
#
# Effect size is defined as:
# effectsize = abs(meangroup1 - meangroup2) / stdevofbothgroups
# abs( mean( fade$visited ) - mean( nofade$visited ) ) / sd( data$visited ), 
# We assume a power of 0.8 (a good estimate according to wikipedia)
# Then we plug those into the pwr.t.test function like:
# 
# desired <- pwr.t.test( 
#   d=effectsize # from above 
#   sig.level=.05, 
#   power=0.8, 
#   type="two.sample"  # changes if we do paired tests, or one sided
# )
# `desired` contains information about power, n, etcetera. We want `desired$n`
# A heuristic if your actual data are non-normal (given we are using tests for normal data) is to add 15% to n.
# Also, `desired$n` is initially the number in *each* group, so we need to multiply by 2
# desired$n * 1.15 * 2 # participants needed for a "safe" experiment given the means and stdev
#shinyApp(
#  
#  ui = fluidPage(
#    #  Application title
#    titlePanel("Interactive Power Analysis for Visited"),
#    
#    # Sidebar with sliders that demonstrate various available
#    # options
#    sidebarLayout(
#      sidebarPanel(
#        # Simple integer interval
#        sliderInput("group1", "Group1:", 
#                    min=0, max=50, value=mean(fade$visited)),
#        
#        sliderInput("group2", "Group2:", 
#                    min=0, max=50, value=mean(nofade$visited))
#      ),
#      
#      # Show a table summarizing the values entered
#      mainPanel(
#        tableOutput("values")
#      )
#  )),
#  
#  server = function(input, output) {
#    # Reactive expression to compose a data frame containing all of
#    # the values
#    sliderValues <- reactive({
#      
#      numParticipants <- pwr.t.test( 
#        d=abs(   mean(   input$group1 ) - 
#                 mean(   input$group2 ) ) / 
#                 14.28, 
#        sig.level=.05, 
#        power=0.8, 
#        type="two.sample" 
#      )$n * 1.15 * 2
#      
#      # Compose data frame
#      data.frame(
#        Name = c("group1", 
#                 "group2",
#                 "necessaryN"),
#        Value = as.character(c(input$group1, 
#                               input$group2,
#                               numParticipants)), 
#        stringsAsFactors=FALSE)
#    }) 
#    
#    # Show the values using an HTML table
#    output$values <- renderTable({
#      sliderValues()
#    })
#  },
#  
#  options = list(height = 500)
#)

library(pwr)

safety <- subset(filterResponseTimesPerRow, Type=="Safety")
security <- subset(filterResponseTimesPerRow, Type=="Security")

# our current difference
pwr.t.test( 
  d=abs( mean(   safety$ResponseTime ) - 
         mean( security$ResponseTime ) ) / 
         sd(     filterResponseTimesPerRow$ResponseTime ), 
  sig.level=.05, 
  power=0.8, 
  type="two.sample" 
)$n * 1.15 * 2

# assuming a 2.5 second reliable difference
pwr.t.test( 
  d=abs( 2500 ) / 
         sd(     filterResponseTimesPerRow$ResponseTime ), 
  sig.level=.05, 
  power=0.8, 
  type="two.sample" 
)$n * 1.15 * 2


```
**Note** that the `echo = FALSE` parameter can be added to the code chunk to prevent printing of the R code that generates the plot.
